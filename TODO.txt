TODO
Message
	Move Network.broadcast() and Session.send() to Message
		-> Message.send(User remoteUser)
				-> if session not initiated: create it
				-> else get session.oos and write object to stream
		-> no need for message.label() when broadcasting
Network
	Fill a table with active users as they declare themselves (=> no servers for now)
DB
	Read/store history (SQLite)
Tests
	Try/catch: develop (e.g. java.net.ConnectException not caught)
	class Test: supports CLI args (cf. lib org.apache.commons.cli)
	Mockito, etc.
	=> unit tests!!!



OPTIMIZATION/EXTENDED FEATURES
History
	use receive buffer: do not store the entire history in memory
		msg received -> update DB && display -> flush buffer
ArrayList -> Array (more efficient?)
Session
	check redundancies in table 'sessions' (sessions can be opened by server and by client on the same side!)
GUI
	Save username and write it by default in the login form
Correct warnings
Add @Override whenever needed
Assess quality of connection (e.g. ping or TCP information (window size, etc.))
	(dateSent, dateReceived) useless for this task because the two machines aren't necessarily sync to the same clock
Security
	Authentication (certificates), integrity (signature)
	Username not used anymore as a way to id users



CHOICES
Network stream
	#1. Library for Java objects serialization
		ObjectOutputStream, ObjectInputStream
		http://www.java2s.com/Tutorial/Java/0180__File/ReadingBasicDataFromanObjectStream.htm
	#2. Homemade: Message -> frame (e.g.: ID:4B CONTENT)-> ~~~~~~~ -> frame -> Message

Network infrastructure
				 TCP (over SSL?) / UDP (announcements)
	App1 (LAN1) -> ~~~~~~~~~~ -> App2 (LAN1)
						|
						|
					Server? (e.g. to centralize list of active users)

DB
	#1. SQLite: cool (single table, clean)
		Table
			History(remoteUsername, msgType/marker, timestamp, content, bool sent/received)
	#2. JSON/XML (dirtier but easier: one file per conversation?)

Network class
	Thread1: listening (TCP port, any addr, etc.)
	Thread2: waiting for user action
