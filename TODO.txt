TODO
-Network: rm it
	mv methods to User or Session
	User.getActiveUsers() (static), User.broadcast() (static), user.getSession()?
	put everything in User?
-tests
	try/catch: develop (e.g. java.net.ConnectException not caught)
	class Test: supports CLI args (cf. lib org.apache.commons.cli)
	Mockito, etc.
	=> unit tests!!!
-DB: read/store history (SQLite)
-message
	do not consider message for ID (cf. code) as TEXT -> send it directly via TCP?
-network
	implement support for broadcast



OPTIMIZATION/EXTENDED FEATURES
-history
	use receive buffer: do not store the entire history in memory
		msg received -> update DB && display -> flush buffer
-session
	check redundancies in table 'sessions' (sessions can be opened by server and by client on the same side!)
-save username and write it by default in the login form
-server
	keep up-to-date list of users: {username, IP addr, port number}
-correct warnings
-ping: assess quality of connection
	(dateSent, dateReceived) useless because the two machines aren't necessarily sync to the same clock


CHOICES
Network stream
	#1. Library for Java serialization
		ObjectOutputStream, ObjectInputStream
		http://www.java2s.com/Tutorial/Java/0180__File/ReadingBasicDataFromanObjectStream.htm
	#2. Homemade: Message -> frame (e.g.: ID:4B CONTENT)-> ~~~~~~~ -> frame -> Message

Network infrastructure
				 TCP (over SSL?) / UDP (announcements)
	App1 (LAN1) -> ~~~~~~~~~~ -> App2 (LAN1)
						|
						|
					Server? (e.g. to centralize list of active users)

DB
	#1. SQLite: cool (single table, clean)
		Table
			History(remoteUsername, msgType/marker, timestamp, content, bool sent/received)
	#2. JSON/XML (dirtier but easier: one file per conversation?)

Network class
	Thread1: listening (TCP port, any addr, etc.)
	Thread2: waiting for user action